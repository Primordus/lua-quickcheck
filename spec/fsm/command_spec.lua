local random = require 'lqc.random'
local r = require 'lqc.report'
local command = require 'lqc.fsm.command'
local property = require 'lqc.property'
local lqc = require 'lqc.quickcheck'
local lqc_gen = require 'lqc.lqc_gen'
local int = require 'lqc.generators.int'
local elements = lqc_gen.elements


local function is_command(x, cmd_name, func)
  return type(x) == 'table' 
    and x.state_name == cmd_name 
    and x.func == func
    and type(x.args) == 'table'  -- a generator, args will be given to the func
end


local function is_stop_command(x)
  return type(x) == 'table'
    and x.state_name == 'stop'
    and type(x.func) == 'function'
    and type(x.args) == 'table'
end


local function do_setup()
  random.seed()
  lqc.init(100, 100)
  lqc.properties = {}
  r.report = function() end
end


describe('command generator', function()
  before_each(do_setup)

  describe('pick function', function()
    it('should pick a command (state name + function + args)', function()
      local cmd_name = 'test_command'
      local function test_func() end
      local spy_check = spy.new(function(x) 
        return is_command(x, cmd_name, test_func) 
      end)
      property 'command generator should pick a valid command for the FSM' {
        generators = { 
          command { cmd_name, test_func, {} } 
        },
        check = spy_check
      }
      lqc.check()
      assert.spy(spy_check).was.called(lqc.iteration_amount)
    end)
  end)

  describe('shrink function', function() 
    it('should only shrink the args generated by the command', function()
      local shrunk_value
      r.report_failed_property = function(_, _, shrunk_vals)
        shrunk_value = shrunk_vals[1]
      end
      local cmd_name = 'another_test_command'
      local test_func = function(x) return x == 0 end

      property 'command generator should only shrink args' {
        generators = {
          command { cmd_name, test_func, {
            elements { 1, 2, 3 }
          }}
        },
        check = function(x)
          return x.func(x.args[1])  -- always fails
        end
      }
      
      for _ = 1, 10 do
        shrunk_value = nil
        lqc.check()
        assert.equal(cmd_name, shrunk_value.state_name)
        assert.equal(test_func, shrunk_value.func)
        assert.equal(1, #shrunk_value.args)
        assert.equal(1, shrunk_value.args[1])
      end
    end)

    it('should shrink nothing if no args are specified', function()
      local shrunk_value
      r.report_failed_property = function(_, _, shrunk_vals)
        shrunk_value = shrunk_vals[1]
      end
      local cmd_name = 'another_test_command'
      local test_func = function() return false end

      property 'command generator should only shrink args' {
        generators = { command { cmd_name, test_func, {} } },
        check = function(x)
          return x.func()  -- always fails
        end
      }
      
      for _ = 1, 10 do
        shrunk_value = nil
        lqc.check()
        assert.equal(cmd_name, shrunk_value.state_name)
        assert.equal(test_func, shrunk_value.func)
        assert.equal(0, #shrunk_value.args)
        assert.same({}, shrunk_value.args)
      end
    end)
  end)

  describe('stop command', function()
    it('should pick a command with state_name "stop"', function()
      local spy_check = spy.new(function(x) return is_stop_command(x) end)
      property 'stop command has state_name "stop"' {
        generators = { command.stop },
        check = spy_check,
      }
      lqc.check()
      assert.spy(spy_check).was.called(lqc.iteration_amount)
    end)
  end)

  describe('command:to_string()', function()
    it('should return a string representation of the command', function()
      local val = 10
      local spy_check = spy.new(function() 
        local cmd0 = command({ 'cmd0', function() end, {} }):pick()
        local cmd1 = command({ 'cmd1', function() end, { int(val) } }):pick()
        local cmd2 = command({ 'cmd2', function() end, { int(val), int(val) } }):pick()

        local str_0_arg = '{ call, cmd0 }'
        local str_1_arg = '{ call, cmd1, ' .. cmd1.args[1] .. ' }'
        local str_2_arg = '{ call, cmd2, ' .. cmd2.args[1] .. ', ' .. cmd2.args[2] .. ' }'

        return cmd0:to_string() == str_0_arg 
          and cmd1:to_string() == str_1_arg
          and cmd2:to_string() == str_2_arg
      end)

      property 'cmd:to_string() returns string representation' {
        generators = {},
        check = spy_check
      }
      lqc.check()
      assert.spy(spy_check).was.called(lqc.iteration_amount)
    end)
  end)
end)

